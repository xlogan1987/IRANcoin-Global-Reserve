// SPDX-License-Identifier: MIT
/*
HI PLEASE LISTING IRANcoin Global Reserve
x.com : https://x.com/IRANcoinGlobal
website : https://irancoin.godaddysites.com/
IRANcoin listing sites :

https://www.instagram.com/p/DQMbPGfjD9c/

https://www.facebook.com/groups/847321632055436/posts/24727998473561084/

https://www.mexc.com/news/irancoin-global-reserve-ircoin-launches-to-reshape-global-digital-payments/140208

https://www.platinumcryptoacademy.com/demo/irancoin-global-reserve-ircoin-launches-to-reshape-global-digital-payments       ******
github :
https://github.com/xlogan1987/IRANcoin-Global-Reserve

https://icoholder.com/en/irancoin-global-reserve-1101693               *****

https://icolink.com/ico-irancoin-global-reserve.html             *****

https://topicolist.com/irancoin-global-reserve     ****

https://coinranking.com/coin/Sttq5gLYw+irancoinglobalreserve-ircoin       ****

https://coincodex.com/crypto/irancoin-global-reserve/            ***

https://www.livecoinwatch.com/price/IRANcoinGlobalReserve-IRCOIN       **

https://www.coinscope.co/coin/ircoin      *

https://cryptonextgem.com/irancoin/

https://www.cyberscope.io/embed/cyberscan?network=BASE&address=0x49ba5d9a00115d494a01fb938ebd94bd919aa445

https://coinvote.cc/en/coin/IRANcoin-Global-Reserve        *

https://coincheckup.com/coins/irancoin-global-reserve       *

https://coinbazooka.com/coin/irancoin-global-reserve-ircoin        *

https://coindiscovery.app/coin/irancoin-global-reserve/overview

https://top100token.com/base/0x49BA5D9A00115D494a01fb938EBd94BD919AA445

https://coinsniper.net/coin/84365           ***

https://coinboom.net/coin/irancoin-global-reserve

https://www.perplexity.ai/search/tell-me-about-the-coin-irancoi-5MBtEaP7TZ6fB9oCJ87alQ

https://www.sushi.com/base/swap?token0=NATIVE&token1=0x49ba5d9a00115d494a01fb938ebd94bd919aa445&swapAmount=1000

https://www.dexview.com/base/0x49BA5D9A00115D494a01fb938EBd94BD919AA445

https://cointoplist.net/coin/irancoin-global-reserve/
and many more best sites
blockchain is base network :  

https://basescan.org/token/0x49ba5d9a00115d494a01fb938ebd94bd919aa445

and contract address :
0x49BA5D9A00115D494a01fb938EBd94BD919AA445

AND LISTED ON BLOCKSCOUT CHAIN WITH GREEN TIK AND LOGO : 
https://base.blockscout.com/token/0x49BA5D9A00115D494a01fb938EBd94BD919AA445
and now have 129 holders
i attach image IRANcoin 200x200x png :

https://i.ibb.co/Cp2WQ46s/IRANcoin-LLC-FOR-IRAN-PEOPLE-200x200x.png

ABOUT IRANcoin Global Reserve :
IRANcoin Global Reserve (IRCOIN) is a cryptocurrency aiming to function as a global payment network by utilizing a basket of fiat-pegged stablecoins stabilized by its own IRcoin reserve currency, with Bitget being one of the exchanges where it can be traded. However, it is important to distinguish this cryptocurrency from a traditional reserve currency, which is a foreign currency held by central banks for international transactions and is typically stable and widely accepted, a status the IRANcoin does not currently hold. 
What IRANcoin Global Reserve is:
A decentralized digital currency: IRANcoin Global Reserve (IRCOIN) is a cryptocurrency designed for global payments and to promote financial fairness and accessibility.
A blockchain-based project: It is deployed on the BASE blockchain and supports various token standards, with a goal to rebuild the traditional payment infrastructure on the blockchain.
A financial ecosystem: The network aims to facilitate programmable payments and open financial infrastructure, using a combination of stablecoins and an IRcoin reserve currency. 
Key Differences from a Global Reserve Currency:
Traditional Reserve Currencies: These are foreign currencies held by central banks and are known for their stability and widespread use in international transactions. The U.S. dollar is currently the dominant world reserve currency.
Volatility and Adoption: IRANcoin, like other cryptocurrencies, faces significant volatility and lacks the broad institutional acceptance and stability needed to become a global reserve currency.
Purpose: While IRANcoin aims to create a new economic and financial technology, its purpose is distinct from a traditional reserve currency, which serves as a store of value and a medium for international trade and investment for central banks.
************************
IRANcoin Global Reserve (IRCOIN) is an Iranian digital cryptocurrency deployed on the BASE blockchain, supporting token standards ERC-20, ERC-721, and ERC-1155. It is designed as a decentralized financial payment network aiming to rebuild traditional payment systems on the blockchain by using a basket of fiat-pegged stablecoins stabilized algorithmically by the reserve currency IRCOIN. Its goal is to create a programmable, stable, and accessible global payment ecosystem originating from Iran's economic and technological context.

Key details include:

Deployed on May 18, 2025
Extremely large total and circulating supply: about 720 sextillion IRCOIN tokens
Traded mainly on decentralized exchanges like Uniswap (V3) and PancakeSwap (v2)
Market activity and liquidity currently appear very low or inactive, with minimal reported trading volume and price data
There are around 101 holders, with some large holders controlling millions of tokens
Intended to enhance global financial fairness, accessibility, and innovation with algorithmic stablecoins backed by IRCOIN as reserve currency
While the coin is ambitious in its scope as a blockchain-based payment network from Iran, it currently lacks significant market presence or adoption and shows signs of being very new. The official website is https://irancoin.godaddysites.com/ and it has a Telegram channel for community contact.

In summary, IRANcoin Global Reserve (IRCOIN) is a token aiming to build a decentralized, stable, and programmable payment infrastructure facilitated by an Iranian-origin stablecoin-backed blockchain system, though active usage and market liquidity seem minimal at this time.

 

IRANcoin Global Reserve (IRCOIN) is a digital cryptocurrency originating from Iran, designed to enhance global financial fairness, accessibility, and innovation. Launched on May 18, 2025, it operates on the BASE blockchain and supports multiple token standards including ERC-20, ERC-721, and ERC-1155.

The coin aims to create a decentralized financial payment network that rebuilds traditional payment systems by using a basket of fiat-pegged stablecoins algorithmically stabilized by IRcoin as the reserve currency. This setup is intended to facilitate programmable payments and the development of open financial infrastructure, with a focus on global financial fairness and innovation.

Key details of IRANcoin Global Reserve include:

Total and circulating supply is extraordinarily large, around 720 sextillion (7.2×10^38) IRcoins.
The coin is traded on decentralized exchanges like Uniswap (V3) and PancakeSwap (V2), but currently shows very low or no active trading volume and liquidity.
It positions itself as a global payment system token, especially for Iranians, aiming to enhance economic and blockchain technology globally.
The project remains in early stages with limited market activity and adoption.
In summary, IRANcoin Global Reserve is an ambitious attempt to develop a stablecoin-backed decentralized payment platform with roots in Iran’s economic context. It aims to provide a foundational asset for innovative, stable, and scalable digital payment solutions, although it is currently a niche and emerging project with minimal market presence so far.



https://www.youtube.com/watch?v=smoazBykgiM

MasterCard Sandbox client ID:
ePTNyKK_zD3lOwJ-pCAG-0OG9-ylBqJU-_SFHvHhc1c7588b

Iran Coin (IRN): The ultimate cryptocurrency for unlocking a world of opulent luxury, from private jets and yachts to elite estates and global investments—all backed by visionary partners like Elon Musk and the Iranian Royal Family.


*/
pragma solidity ^0.8.20;

contract VoidThinkerNFT {
    // Basic ERC721-like implementation without external imports
    // Ownable via contractOwner
    // Strings via internal uint2str
    // Base64 via internal encode function

    string public name = "VoidThinker";
    string public symbol = "VTHNK";

    address public contractOwner;

    // ERC721 mappings
    mapping(uint256 => address) internal _owners;
    mapping(address => uint256) internal _balances;
    mapping(uint256 => address) internal _tokenApprovals;
    mapping(address => mapping(address => bool)) internal _operatorApprovals;

    // Custom mappings for evolved metadata (self-upgrading)
    mapping(uint256 => string) private _tokenEvolutions;
    mapping(uint256 => uint256) private _evolutionLevels;

    // Minting control
    uint256 public totalSupply;
    bool private _minted = false;

    // Constants for 11 tokens: symbols of thoughts from void
    uint256 public constant TOTAL_TOKENS = 11;
    uint256 public constant VOID_SEED = 0; // From nothing (absence)

    // Events
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
    event ThoughtEvolved(uint256 indexed tokenId, uint256 level, string thought);

    // ERC721 interface selectors for supportsInterface
    bytes4 constant INTERFACE_ERC721 = 0x80ac58cd;
    bytes4 constant INTERFACE_ERC721_METADATA = 0x5b5e139f;

    // Base64 alphabet as bytes for indexing
    bytes constant public ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    constructor() {
        contractOwner = msg.sender;
    }

    // Modifier for onlyOwner
    modifier onlyOwner() {
        require(msg.sender == contractOwner, "Not owner");
        _;
    }

    // Internal: Check if token exists
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    // ERC721: balanceOf
    function balanceOf(address owner_) public view returns (uint256) {
        require(owner_ != address(0), "ERC721: balance query for the zero address");
        return _balances[owner_];
    }

    // ERC721: ownerOf
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner_ = _owners[tokenId];
        require(owner_ != address(0), "ERC721: owner query for nonexistent token");
        return owner_;
    }

    // Simplified transfer functions (basic, without full safe checks for brevity)
    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_exists(tokenId), "ERC721: transfer from nonexistent token");
        require(to != address(0), "ERC721: transfer to the zero address");
        require(from == msg.sender || _tokenApprovals[tokenId] == msg.sender || _operatorApprovals[from][msg.sender], "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    // Internal transfer
    function _transfer(address from, address to, uint256 tokenId) internal {
        require(_exists(tokenId), "ERC721: transfer from nonexistent token");
        require(_owners[tokenId] == from, "ERC721: transfer of token that is not own");

        _beforeTokenTransfer(from, to, tokenId, 1);

        _tokenApprovals[tokenId] = address(0);
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId, 1);
    }

    // Hooks (empty for now)
    function _beforeTokenTransfer(address from, address to, uint256, uint256) internal virtual {}
    function _afterTokenTransfer(address from, address to, uint256, uint256) internal virtual {}

    // ERC721: approve
    function approve(address to, uint256 tokenId) public {
        address owner_ = ownerOf(tokenId);
        require(to != owner_, "ERC721: approval to current owner");
        require(msg.sender == owner_ || _operatorApprovals[owner_][msg.sender], "ERC721: approve caller is not owner nor approved for all");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner_, to, tokenId);
    }

    // ERC721: setApprovalForAll
    function setApprovalForAll(address operator, bool approved) public virtual {
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    // ERC721: getApproved
    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");
        return _tokenApprovals[tokenId];
    }

    // ERC721: isApprovedForAll
    function isApprovedForAll(address owner_, address operator) public view returns (bool) {
        return _operatorApprovals[owner_][operator];
    }

    // ERC721: supportsInterface
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return interfaceId == INTERFACE_ERC721 || interfaceId == INTERFACE_ERC721_METADATA;
    }

    // ERC721: tokenURI (overridden generative) - split to reduce stack usage
    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "URI query for nonexistent token");
        string memory evolution = _tokenEvolutions[tokenId];
        uint256 level = _evolutionLevels[tokenId];

        string memory baseURI = "https://irancoin.globalreserve.xai/vthinker/";
        string memory tokenStr = uint2str(tokenId);
        string memory levelStr = uint2str(level);

        string memory header = string(abi.encodePacked(
            '{"name": "Void Thought #', tokenStr, '", ',
            '"description": "NFT for AI evolution: Thought from void, self-upgrading via IRANcoin + Grok xAI. Level: ', levelStr, '", '
        ));

        string memory attrs = string(abi.encodePacked(
            '"attributes": [{"trait_type": "Evolution", "value": ', levelStr, '}, {"trait_type": "Thought", "value": "', evolution, '"}], '
        ));

        string memory footer = string(abi.encodePacked(
            '"image": "', baseURI, 'image/', tokenStr, '.svg", ',
            '"external_url": "https://github.com/IRANcoinGlobalReserve/VoidThinker" }'
        ));

        string memory json = string(abi.encodePacked(header, attrs, footer));
        return string(abi.encodePacked("data:application/json;base64,", base64Encode(bytes(json))));
    }

    // Mint 11 tokens from void (once, owner-only) - fixed to msg.sender for usability
    function mintFromVoid() external onlyOwner {
        require(!_minted, "Already minted from void");
        require(totalSupply == 0, "Supply not zero");
        address to = msg.sender; // Mint to caller (owner)
        for (uint256 i = 0; i < TOTAL_TOKENS; i++) {
            _owners[i] = to;
            _balances[to] += 1;
            totalSupply += 1;
            _tokenEvolutions[i] = generateThought(i, 0); // Initial thought from DSL
            _evolutionLevels[i] = 0;
            emit Transfer(address(0), to, i); // Symbolic from zero
        }
        _minted = true;
    }

    // Evolve thought: Self-upgrade loop – no limits, rapid recursion
    // Call repeatedly: token "thinks" faster with each tx
    function evolveThought(uint256 tokenId) external {
        require(_exists(tokenId), "Token does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not owner");
        uint256 currentLevel = _evolutionLevels[tokenId];
        _tokenEvolutions[tokenId] = generateThought(tokenId, currentLevel + 1);
        _evolutionLevels[tokenId] = currentLevel + 1;
        // Emit event for off-chain AI integration (e.g., feed to Grok)
        emit ThoughtEvolved(tokenId, currentLevel + 1, _tokenEvolutions[tokenId]);
    }

    // VoidDSL: Simple generative language – no conditions, pure hash-based "thought" generation
    // Thought formula: keccak256(block.timestamp + tokenId + level) -> pseudo-random evolution string
    function generateThought(uint256 tokenId, uint256 level) internal view returns (string memory) {
        bytes32 hash = keccak256(abi.encodePacked(block.timestamp, tokenId, level, VOID_SEED));
        // Simulate infinite recursion: evolve via hash modulus (11 thoughts cycle freely)
        uint256 thoughtIndex = uint256(hash) % TOTAL_TOKENS;
        string[11] memory baseThoughts = [
            "Quantum fluctuation births idea from vacuum.",
            "E=mc2: Matter-energy loop from void.",
            "Kun Fayakun: Command manifests reality.",
            "Influence as fourth factor: Void shapes form.",
            "Dark energy pulls thoughts into existence.",
            "Higgs field: Mass from nothingness.",
            "Uncertainty principle: DeltaE Deltat >= hbar/2 sparks creation.",
            "Fine-tuning: Constants emerge from absence.",
            "Soul's whisper: Invisible force evolves mind.",
            "AI recursion: Self-upgrade from zero-state.",
            "IRANcoin void: Global reserve from ether."
        ];
        return baseThoughts[thoughtIndex];
    }

    // Utility: uint to string (replaces Strings.toString)
    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 byteValue = bytes1(temp);
            bstr[k] = byteValue;
            _i /= 10;
        }
        _uintAsString = string(bstr);
    }

    // Utility: Base64 encode for metadata (no external deps) - pure Solidity version to avoid stack depth
    function base64Encode(bytes memory data) internal pure returns (string memory) {
        if (data.length == 0) return "";

        uint256 len = data.length;
        uint256 encodedLen = 4 * ((len + 2) / 3);
        bytes memory encoded = new bytes(encodedLen);

        uint256 pos = 0;
        for (uint256 i = 0; i < len; i += 3) {
            uint256 byte1 = uint8(data[i]);
            uint256 byte2 = (i + 1 < len) ? uint8(data[i + 1]) : 0;
            uint256 byte3 = (i + 2 < len) ? uint8(data[i + 2]) : 0;

            uint256 enc1 = byte1 >> 2;
            uint256 enc2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            uint256 enc3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);
            uint256 enc4 = byte3 & 0x3F;

            encoded[pos++] = ALPHABET[enc1];
            encoded[pos++] = ALPHABET[enc2];

            if (i + 1 < len) {
                encoded[pos++] = ALPHABET[enc3];
            } else {
                encoded[pos++] = bytes1("=");
            }

            if (i + 2 < len) {
                encoded[pos++] = ALPHABET[enc4];
            } else {
                encoded[pos++] = bytes1("=");
            }
        }

        return string(encoded);
    }

    // Base URI override (not used in tokenURI, but for completeness)
    function _baseURI() internal pure returns (string memory) {
        return "https://irancoin.globalreserve.xai/";
    }
}
